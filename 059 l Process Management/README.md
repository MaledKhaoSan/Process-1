<a id="process-management"></a>
# :round_pushpin: What is Process Management in Linux?
Process Management ใน Linux คือกระบวนการควบคุมและตรวจสอบกระบวนการที่กำลังทำงาน การสร้าง การควบคุม และการยุติการทำงานทั้งหมดในระบบ รวมถึงการจัดสรรทรัพยากรของกระประมวลผล โดยหลักการของ Process Management ประกอบไปด้วย 3 หลักนี้
<br><br>
1. Process Creation (การเริ่มต้นกระบวนการ):
<br>การเริ่มต้นกระบวนการใหม่, ซึ่งอาจเกิดจากการใช้คำสั่งหรือโปรแกรมที่ทำงานตลอดเวลา.
      <br><br>
2. Process Control (การควบคุมการทำงาน):
<br>การควบคุมกระบวนการที่กำลังทำงาน ลำดับการทำงาน ว่ากระบวนการใดสำคัญกว่าจึงมาก่อน การติดตามและจัดการกระบวนการที่กำลังทำงานอยู่ การจัดสรร CPU, หน่วยความจำ, ทรัพยากรอื่นๆ
      <br><br>
3. Process Termination (การหยุดกระบวนการ):
<br>การสิ้นสุดการทำงานของกระบวนการเมื่อทำงานเสร็จสิ้น หรือ การที่ผู้ใช้บังคับให้หยุด, โดยจะคืนทรัพยากรที่ใช้ไป และสิ้นสุดการทำงานของตัวเอง

> [!TIP]
> ด้วยหลักการของ Process Management ทั้งสามนี้ช่วยให้ระบบปฏิบัติการสามารถจัดการกระบวนการในระบบได้อย่างถูกต้อง 

---

<a id="process-states"></a>
# :bulb: Stages of a Process in Linux
ในกระบวนการทำงาน (process) จะมีสถานะต่างๆ ตลอดวงจรการทำงาน การมีอยู่ของ process states ช่วยให้ระบบสามารถจัดการทรัพยากรและทำงานของกระบวนการได้อย่างมีประสิทธิภาพ process states ใน Linux มีดังนี้ ??

---

<a id="process-creation"></a>
# :bulb: Process Creation
พื้นฐานหรือหลักการทำงานของ Process Creation จะทำหน้าที่สร้างกระบวนการใหม่ (process) เพื่อรันโปรแกรมนั้น ๆ บนระบบปฏิบัติการ คือการสร้างโปรแกรมใหม่ขึ้นมาเพื่อทำงานตามชุดคำสั่งและ Process Creation สามารถเกิดขึ้นได้หลายวิธีตามบริบทที่ใช้ เช่น


1. ผู้ใช้รันโปรแกรม:
    - ผู้ใช้พิมพ์คำสั่งบน command line เช่น `ls`, `cd`, `mkdir`, `grep`
    - ผู้ใช้รันโปรแกรมผ่าน graphical user interface (GUI).

        ### :computer: ตัวอย่างเหตุการณ์เมื่อผู้ใช้พิมพ์คำสั่งบน Command Line
        #### `ls` - แสดงรายการ file และ directory
        > คำสั่ง `ls` จะแสดงเนื้อหาใน directory ปัจจุบัน ระบุรายการ file และ directory ทั้งหมด
        > ```ruby
        > $ ls
        > Desktop  Documents  Downloads  Music  Pictures  Videos
        > ```

        #### `cd` - เปลี่ยน directory
        > คำสั่ง `cd` จะเปลี่ยน directory ปัจจุบันเป็น "Documents."
        > ```ruby
        > $ cd Documents
        > ```

        #### `mkdir` - สร้าง directory
        > คำสั่ง `mkdir` จะสร้าง directory ใหม่ชื่อ "NewDirectory."
        > ```ruby
        > $ mkdir NewDirectory
        > ```

        #### `grep` - ค้นหาข้อความในไฟล์
        > คำสั่ง `grep` จะค้นหาข้อความที่ระบุในเนื้อหาของไฟล์ (เช่น "รูปแบบ" ใน "ชื่อไฟล์.txt").
        > ```ruby
        > $ grep "รูปแบบ" ชื่อไฟล์.txt
        > ```

2. การเริ่มทำงานโดยระบบปฏิบัติการ:
    - ระบบปฏิบัติการรัน scripts ที่ตั้งเวลาไว้
    - ระบบปฏิบัติการเริ่มโปรแกรม daemon ที่ทำงานพื้นหลัง
    - ระบบปฏิบัติการตอบสนองต่อ events ต่างๆ เช่น การกดปุ่มบน keyboard
        ### :computer: ตัวอย่างเหตุการณ์ Process Creation จาก Scripts ที่ตั้งเวลาไว้

        #### สมมติว่าเรามี script ชื่อ `daily_backup.sh` 
        > ที่ใช้สำหรับสำรองข้อมูลทุกวันเวลา 12:00 นาฬิกา โดยให้ระบบปฏิบัติการเรียกใช้ script นี้ตามกำหนดเวลาที่กำหนด
        > ```bash
        > # daily_backup.sh
        > #!/bin/bash
        > 
        > # ทำงานสำหรับการสำรองข้อมูล
        > echo "Running daily backup..."
        > # คำสั่งสำหรับสำรองข้อมูล
        > # ...
        > 
        > # สิ้นสุด script
        > ```
        > จากนั้นให้กำหนดตัวแปร environment หรือ cron job ในระบบปฏิบัติการเพื่อทำงาน script ตามเวลาที่ต้องการ
        >```bash
        ># ตั้งค่า cron job เพื่อเรียกใช้ script ทุกวันที่ 2 เวลา 2 โมงเช้า
        >0 12 * * * /path/to/daily_backup.sh
        >```
        >
        > ในที่นี้เราให้ cron job ระบบปฏิบัติการเรียกใช้ `daily_backup.sh` ทุกวันเวลา 12:00 นาฬิกา เป็นตัวอย่างการเริ่มต้นกระบวนการ (Process Creation) จาก script ที่ตั้งเวลาไว้

        <br>

        ### :computer: ตัวอย่างเหตุการณ์ Process Creation จาก Daemon

        โปรแกรม daemon เป็นโปรแกรมที่ทำงานแบบ <a href="">background process</a> โดยไม่ต้องมีผู้ใช้เรียกใช้งานโดยตรง เรามีตัวอย่างเป็น daemon ที่เป็น web server ซึ่งทำงานตลอดเวลาเพื่อตอบรับ requests จาก clients

        > ตัวอย่างโปรแกรม daemon ของ web server (ในที่นี้เราให้ตั้งตัวอย่างเป็น Apache HTTP Server)
        > ```bash
        > # ในการเริ่ม Apache HTTP Server เป็น daemon
        > sudo service apache2 start
        > ```
        > 
        > ในที่นี้เราให้ `apache2` เป็นตัวอย่างของโปรแกรม daemon ที่ทำงานพื้นหลังโดยไม่ต้องมีผู้ใช้เรียกใช้งานโดยตรง เป็นตัวอย่างการเริ่มต้นกระบวนการ (Process Creation) จากโปรแกรม daemon

> [!TIP]
> การสร้างกระบวนการใหม่ของ Process Creation นั้นอาจจะใช้วิธีการ fork() และ exec() หรือวิธีการอื่น ๆ ขึ้นอยู่กับระบบปฏิบัติการและลักษณะการทำงาน
<br>

---

> [!NOTE]
> ## :raising_hand: ต่อไปเราจะลงลึกในหัวข้อ Process Control (การควบคุมการทำงาน)
> ที่มีบทบาทสำคัญในการจัดการลำดับการทำงานของกระบวนการ, การติดตามและจัดการกระบวนการที่กำลังทำงานอยู่, และการจัดสรรทรัพยากรเช่น CPU และหน่วยความจำ.
>

---

# :bulb: Process Control

Process Control (การควบคุมการทำงาน) เป็นส่วนสำคัญของ Process Management ในระบบ Linux ซึ่งมีบทบาทในการควบคุมลำดับการทำงานของกระบวนการ, การติดตามและจัดการกระบวนการที่กำลังทำงาน, และการจัดสรรทรัพยากร เช่น CPU, หน่วยความจำ, และทรัพยากรอื่น ๆ ต่อไปนี้คือส่วนที่ศึกษาถึง Process Control:

## 2. บทบาทหรือหน้าที่บน Linux

### 2.1 พื้นฐานหรือหลักการทำงาน
- **Process Control (การควบคุมการทำงาน):**
    - **หน้าที่หลัก:** การควบคุมลำดับการทำงานของกระบวนการในระบบ.
    - **การติดตามและจัดการ:**
        - ควบคุมและติดตามลำดับของกระบวนการที่กำลังทำงาน.
        - จัดการการทำงานของกระบวนการ เช่น การหยุด, ทำให้ทำงานในพื้นหลัง (background), หรือเรียกกลับมาทำงาน (foreground).
    - **การจัดสรรทรัพยากร:**
        - การจัดสรร CPU และหน่วยความจำให้แก่กระบวนการที่มีความสำคัญ.

### 2.2 การติดตามและจัดการกระบวนการ
- **ติดตามและจัดการ:**
    - `ps`: แสดงข้อมูลเกี่ยวกับกระบวนการที่กำลังทำงาน.
    - `kill`: ส่งสัญญาณให้กระบวนการหยุดทำงาน.
    - `renice`: เปลี่ยนระดับความสำคัญของกระบวนการ.
    - `^z`, `bg`, `fg`: การจัดการกระบวนการในรูปแบบของ Job Control.

### 2.3 การจัดสรรทรัพยากร
- **การจัดสรรทรัพยากร:**
    - `nice`: กำหนดระดับความสำคัญของกระบวนการ.
    - `renice`: เปลี่ยนระดับความสำคัญของกระบวนการที่กำลังทำงาน.
    - `chrt`: กำหนดและตรวจสอบ scheduling policy.

---

> [!NOTE]
> ## :raising_hand: ต่อไปเราจะพูดถึง Process Termination (การหยุดกระบวนการ)
> ซึ่งเป็นขั้นตอนสุดท้ายใน Process Management ที่เกี่ยวข้องกับการสิ้นสุดกระบวนการทำงานของกระบวนการ.
>

---


# :bulb: Process Termination

Process Termination (การหยุดกระบวนการ) เป็นขั้นตอนสุดท้ายใน Process Management ในระบบ Linux ซึ่งมีบทบาทในการสิ้นสุดกระบวนการทำงานของกระบวนการ โดยมีลักษณะการทำงานดังนี้:

## 3. บทบาทหรือหน้าที่บน Linux

### 3.1 พื้นฐานหรือหลักการทำงาน
- **Process Termination (การหยุดกระบวนการ):**
    - **หน้าที่หลัก:** การสิ้นสุดกระบวนการทำงานของกระบวนการ.
    - **สาเหตุของการหยุด:**
        - การทำงานเสร็จสิ้น: กระบวนการทำงานของโปรแกรมเสร็จสิ้นโดยปราศจากข้อผิดพลาด.
        - การถูกบังคับให้หยุด: กระบวนการถูกส่งสัญญาณจากโปรแกรมหรือผู้ใช้ให้หยุดทำงาน.
    - **ผลลัพธ์:**
        - การหยุดกระบวนการทำงาน.
        - คืนทรัพยากรที่ใช้ไป, เช่น หน่วยความจำ, CPU, และทรัพยากรอื่น ๆ.

### 3.2 การสิ้นสุดกระบวนการ
- **การสิ้นสุดกระบวนการ:**
    - `kill`: ส่งสัญญาณให้กระบวนการหยุดทำงาน.
    - `pkill`: หยุดกระบวนการที่มีชื่อที่ตรงกับคำที่กำหนด.
    - `killall`: หยุดกระบวนการที่มีชื่อที่ตรงกับคำที่กำหนด.

### 3.3 การคืนทรัพยากร
- **การคืนทรัพยากร:**
    - `wait`: รอจนกระบวนการลูกค้าทำงานเสร็จ.
    - `exit`: สิ้นสุดการทำงานของกระบวนการและส่งค่ากลับ.

---

> [!TIP]
> ## :raising_hand: สรุป
> Process Termination (การหยุดกระบวนการ) เป็นขั้นตอนสุดท้ายของ Process Management ที่เกี่ยวข้องกับการสิ้นสุดกระบวนการทำงานของกระบวนการ โดยมีการใช้คำสั่ง `kill`, `pkill`, `killall` เพื่อส่งสัญญาณหยุดทำงานแก่กระบวนการ และใช้ `wait` และ `exit` เพื่อรอและคืนทรัพยากรต่าง ๆ ที่ใช้งานของกระบวนการก่อนหน้า.
>

---
